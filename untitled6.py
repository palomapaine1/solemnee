# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G9yh4wlXEdDho0ojgLcZPqKlxiAGq9du
"""

import pandas as pd
import requests
import streamlit as st
import io

# Función para obtener datos de la API y manejar errores
@st.cache_data
def obtener_datos_api(api_url):
    response = requests.get(api_url)
    if response.status_code == 200:
        data = response.json()
        return pd.DataFrame(data)
    else:
        st.error('Error al obtener los datos de la API.')
        return None

# URL de la API
api_url = "https://restcountries.com/v3.1/all"

# Obtener y procesar datos
df = obtener_datos_api(api_url)
if df is not None:
    # Procesar y limpiar datos
    df['Nombre'] = df['name'].apply(lambda x: x.get('common', 'Desconocido') if isinstance(x, dict) else None)
    df['Región'] = df.get('region', 'Desconocido')
    df['Población'] = df.get('population', 0)
    df['Área (km²)'] = df.get('area', 0)
    df['Fronteras'] = df['borders'].apply(lambda x: len(x) if isinstance(x, list) else 0)
    df['Idiomas Oficiales'] = df['languages'].apply(lambda x: len(x) if isinstance(x, dict) else 0)
    df['Zonas Horarias'] = df['timezones'].apply(lambda x: len(x) if isinstance(x, list) else 0)
    
    # Selección de columnas
    columnas = ['Nombre', 'Región', 'Población', 'Área (km²)', 'Fronteras', 'Idiomas Oficiales', 'Zonas Horarias']
    df_cleaned = df[columnas]

    # Mostrar datos originales
    st.title("Interacción con los datos")
    st.header("Datos originales")
    st.dataframe(df_cleaned)

    # Selección de columnas
    st.header("Seleccionar columnas para visualización")
    columnas_seleccionadas = st.multiselect('Selecciona columnas a visualizar:', df_cleaned.columns, default=df_cleaned.columns)
    df_seleccionado = df_cleaned[columnas_seleccionadas]
    st.dataframe(df_seleccionado)

    # Estadísticas de columnas numéricas
    st.header("Estadísticas")
    st.write("Media:", df_seleccionado.mean(numeric_only=True))
    st.write("Mediana:", df_seleccionado.median(numeric_only=True))
    st.write("Desviación estándar:", df_seleccionado.std(numeric_only=True))

    # Ordenar datos
    st.header("Ordenar datos")
    columna_ordenar = st.selectbox("Selecciona una columna para ordenar:", df_seleccionado.columns)
    orden = st.radio("Selecciona el orden:", ['Ascendente', 'Descendente'])
    df_ordenado = df_seleccionado.sort_values(by=columna_ordenar, ascending=(orden == 'Ascendente'))
    st.dataframe(df_ordenado)

    # Filtrar datos
    st.header("Filtrar datos")
    columnas_numericas = df_cleaned.select_dtypes(include=['number']).columns
    if not columnas_numericas.empty:
        columna_filtro = st.selectbox("Selecciona una columna para filtrar:", columnas_numericas)
        min_val, max_val = st.slider(f"Rango para {columna_filtro}:", float(df_cleaned[columna_filtro].min()), float(df_cleaned[columna_filtro].max()))
        df_filtrado = df_cleaned[(df_cleaned[columna_filtro] >= min_val) & (df_cleaned[columna_filtro] <= max_val)]
        st.dataframe(df_filtrado)
        
        # Descargar datos filtrados
        st.subheader("Exportar datos filtrados")
        formato = st.radio("Formato de descarga:", ["CSV", "Excel"])

        @st.cache_data
        def convertir_a_csv(df):
            return df.to_csv(index=False).encode('utf-8')

        @st.cache_data
        def convertir_a_excel(df):
            buffer = io.BytesIO()
            with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
                df.to_excel(writer, index=False, sheet_name='DatosFiltrados')
                writer.save()
            return buffer.getvalue()

        if formato == 'CSV':
            st.download_button("Descargar CSV", convertir_a_csv(df_filtrado), "datos_filtrados.csv", "text/csv")
        elif formato == 'Excel':
            st.download_button("Descargar Excel", convertir_a_excel(df_filtrado), "datos_filtrados.xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
    else:
        st.warning("No hay columnas numéricas para filtrar.")
else:
    st.error("No se pudieron cargar los datos.")


  
